#!/bin/bash

#   ---------------------------------------------------------------------- copyright and license ---
#
#   File: bin/build.sh
#
#   Copyright ðŸ„¯ 2014, 2016â€”2017, 2019â€”2023 Van de Bugger.
#
#   This file is part of Tapper.
#
#   Tapper is free software: you can redistribute it and/or modify it under the terms of the GNU
#   General Public License as published by the Free Software Foundation, either version 3 of the
#   License, or (at your option) any later version.
#
#   Tapper is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
#   even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along with Tapper.  If not,
#   see <https://www.gnu.org/licenses/>.
#
#   SPDX-License-Identifier: GPL-3.0-or-later
#
#   ---------------------------------------------------------------------- copyright and license ---

#   This is a (thin?) wrapper around `autoreconf && configure && make`. It does few things:
#
#       1.  It runs `autoreconf` if `configure` does not exist or outdated.
#       2.  It creates `_build` directory, and runs other actions from within it.
#       3.  It implements `veryclean` (pseudo)target.
#
#   The last item is quite important because I do not like how it is implemented in `Makefile` â€”
#   it builds a lot of stuff just to delete everything.

set -Eeo pipefail

declare -A color
color[b]='\e[1m'
color[n]='\e[0m'
color[r]='\e[31m'
color[g]='\e[32m'
color[y]='\e[33m'
colors=auto

status=
do_exit() {
    # `do_exit` can be called several times. For example, when `ERR` is trapped, `do_exit` is
    # called, at the end it calls `exit 2`, so `do_exit` is called again as a part of `EXIT` trap.
    # Take care about such recursive calls:
    [[ -z $status ]] || return
    status=$1
    if [[ -z $colors || $colors == auto && ! -t 1 ]]; then
        color=()
    fi
    case $status in
        ( 0 ) printf   "${color[g]}%s${color[n]}\n" '+++++ SUCCESS +++++';;
        ( 3 ) printf "\n${color[y]}%s${color[n]}\n" '***** ABORTED *****';;
        ( * ) printf   "${color[r]}%s${color[n]}\n" '----- FAILURE -----';;
    esac
    exit $status
}

trap "do_exit 0" EXIT
trap "do_exit 2" ERR
trap "do_exit 3" INT

script=$( basename "$0" )
curdir=$( pwd )
bindir=$( dirname "$0" )
srcdir=$( realpath "$bindir/.." )
builddir="$srcdir/_build"
installdir="$builddir/install"

conf_opts=()
make_opts=()
make_vars=()
goals=()

# Last performed action, either clean, very-clean, configure, or make.
last_action=
prep=

banner() {
    printf '%s\n' "[b] ----- $* -----"
}

run() {
    printf '%s\n' "$*"
    "$@"
}

contains() {
    local pattern item
    pattern="$1"
    shift 1
    for item in "$@"; do
        case "$item" in
            ( $pattern )
                return 0
                ;;
            ( * )
                :
                ;;
        esac
    done
    return 1
}

match() {
    local item pattern
    item="$1"
    shift 1
    for pattern in "$@"; do
        case "$item" in
            ( $pattern )
                return 0
                ;;
            ( * )
                :
                ;;
        esac
    done
    return 1
}

help() {
    #     12345678901234567890123456789012345678901234567890123456789012345678901234567890
    echo "$script makes developer life a little bit easier: it creates _build directory"
    echo "and runs autoreconf/configure/make from within it."
    echo ""
    echo "Usage:"
    echo "    $script [--no-colors] [CONFIGURE-OPTION]... [MAKE-OPTION]... [TARGET]..."
    echo "        Build specified or implied targets by running autoreconf/configure/make."
    echo ""
    echo "        Options --with*, --without*, --enable*, --disable*, --prefix and --*dir"
    echo "        are passed to configure, other options and targets are passed to make."
    echo ""
    echo "        Target 'very-clean' (or just 'vc') is treated specially: instead of"
    echo "        passing it to make, $script clears _build directory and all"
    echo "        intermediate files generated by either autoreconf or configure."
    echo ""
    echo "Options:"
    echo "    --no-colors"
    echo "        Disable color output."
    echo ""
    echo "Examples:"
    echo "    $script --help"
    echo "        Print $script help and exit."
    echo ""
    echo "    $script --help-configure"
    echo "        Run configure with --help option."
    echo ""
    echo "    $script help"
    echo "        Show make convenience targets."
    echo ""
    exit 0
}

#   I want to (1) show actions, and (2) minimize output. So, show the rm command only if file
#   actually exists and we are going to remove it, skip echo for non-existent files.
_remove() {
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            run rm "$file"
        elif [[ -d "$file" ]]; then
            run rm -r "$file"
        fi
    done
}

#   Do preparation: create build directory and make it current.
do_prep() {
    [[ "$prep" != "done" ]] || return 0
    local banner="banner 'prep'; banner=':'"    # Show the banner only once.
    [[ -d "$builddir" ]]          || { eval $banner; run mkdir -p "$builddir"; }
    [[ "$builddir" = "$curdir" ]] || { eval $banner; run cd "$builddir";       }
    prep=done
}

do_clean() {
    case "$last_action" in
        ( *clean )
            # Avoid repeating cleaning.
            return 0
            ;;
    esac
    banner 'clean'
    run "$srcdir/bin/clean.sh" "--exclude=config.*" .
    last_action=clean
}

#   Similar to make's maintainer-clean, but does not rebuild configure and Makefile to delete them.
do_very_clean() {
    case "$last_action" in
        ( very-clean )
            # Avoid repeating cleaning.
            return 0
            ;;
    esac
    banner 'very-clean'
    run "$srcdir/bin/clean.sh" .
    _remove "$srcdir"/_aux
    _remove "$srcdir"/_autom4te.cache
    _remove "$srcdir"/_m4
    _remove "$srcdir"/aclocal.m4
    _remove "$srcdir"/configure
    _remove "$srcdir"/config.h.in{,~}
    _remove "$srcdir"/Makefile.in
    last_action=very-clean
}

do_autoreconf() {
    banner 'autoreconf'
    run autoreconf -i "$srcdir"
    last_action=autoreconf
}

do_configure() {
    banner 'configure'
    run "$srcdir/configure" --enable-option-checking=fatal --enable-maintainer-mode "${conf_opts[@]}"
    if [[ " ${conf_opts[*]} " =~ \ --help\  ]]; then
        exit 0
    fi
    printf "%s\n" "${conf_opts[@]}" | sort > .configuration
    # Clear configure options to avoid run it for the next time.
    conf_opts=()
    last_action=configure
}

do_make() {
    local rc=0
    banner 'make'
    run make "${make_opts[@]}" "${make_vars[@]}" "${goals[@]}"
    goals=()
    last_action=make
}

# Build goals accumulated in goal array, and clear the array.
# If goals array is empty, do nothing.
build() {
    if [[ ${#goals[@]} -eq 0 ]]; then
        # Nothing to build.
        return 0
    fi
    if [[
        "$srcdir/configure.ac" -nt "$srcdir/configure"
        || "$srcdir/META.txt" -nt "$srcdir/configure"
    ]]; then
        do_very_clean
    fi
    if [[ ! -e "$srcdir/configure" ]]; then
        do_autoreconf
        # If autoreconf was run (=> configure was rebuilt), make sure (new) configure will run too:
        _remove "Makefile"
    fi
    if [[
        ! -e "Makefile"
        || "$srcdir/Makefile.am" -nt "Makefile"
        || ! -e .configuration
        || ${#conf_opts[@]} -ne 0
            && $( printf "%s\n" "${conf_opts[@]}" | sort ) != $(< .configuration )
    ]]; then
        do_configure
        # If configure was run (=> Makefile was rebuilt), make sure make will rebuild everything:
        if [[ ${goals[0]} != clean ]]; then
            goals=( clean "${goals[@]}" )
        fi
    fi
    do_make
}

# Sets DESTDIR temporary and builds the specified goal.
# DESTDIR can't be set permanently because it badly interferes with distcheck automake goal:
# make creates too long path like "/PATH/_build/install/PATH/_build/blankom4t/_inst/share/aclocal".
# See <https://debbugs.gnu.org/cgi/bugreport.cgi?bug=34166>.
install() {
    DESTDIR="$installdir" build
}

# Parse command line. Collect separately options, variable assignments, and goals.
todo=()
for arg in "$@"; do
    case "$arg" in
        ( --no-colors | --no-color )
            colors=
            export GCC_COLORS=
            ;;
        ( --help )
            help
            ;;
        ( --help-conf | --help-config | --help-configure )
            conf_opts+=( "--help" )
            ;;
        ( --with-* | --without-* | --enable-* | --disable-* | --prefix=* | --*dir=* )
            conf_opts+=( "$arg" )
            ;;
        ( -* )
            make_opts+=( "$arg" )
            ;;
        ( *=* )
            make_vars+=( "$arg" )
            ;;
        ( * )
            todo+=( "$arg" )
            ;;
    esac
done
# If no goals specified explicitly, assume "all" goal.
if [[ "${#todo[@]}" -eq 0 ]]; then
    todo=( "all" )
fi

do_prep

for goal in "${todo[@]}"; do
    case "$goal" in
        ( vc | veryclean | very-clean )
            build               # Build goals accumulated so far.
            do_very_clean       # And then clean.
            ;;
        ( install | install-strip | uninstall )
            build
            goals+=( "$goal" )
            install
            ;;
        ( * )
            goals+=( "$goal" )  # Remember the goal, will build all the goals later.
            ;;
    esac
done
build   # Build goals accumulated so far, if any.

exit 0

# end of file #
